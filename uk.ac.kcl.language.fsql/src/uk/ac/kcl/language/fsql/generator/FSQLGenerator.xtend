/*
 * generated by Xtext 2.25.0
 */
package uk.ac.kcl.language.fsql.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import uk.ac.kcl.language.fsql.fSQL.FSQL
import uk.ac.kcl.language.fsql.fSQL.DatabaseStatements
import uk.ac.kcl.language.fsql.fSQL.CreateDB
import uk.ac.kcl.language.fsql.fSQL.UseDB
import uk.ac.kcl.language.fsql.fSQL.TableStatements
import uk.ac.kcl.language.fsql.fSQL.CreateTable
import uk.ac.kcl.language.fsql.fSQL.InitTable
import uk.ac.kcl.language.fsql.fSQL.SchemaDeclaration
import uk.ac.kcl.language.fsql.fSQL.ColumnDeclaration
import uk.ac.kcl.language.fsql.fSQL.SimpleDeclaration
import uk.ac.kcl.language.fsql.fSQL.PrimaryKey
import uk.ac.kcl.language.fsql.fSQL.ColumnType
import uk.ac.kcl.language.fsql.fSQL.ForeignKey
import uk.ac.kcl.language.fsql.fSQL.CompositeKey

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class FSQLGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val model = resource.contents.head as FSQL
		
		val className = resource.deriveClassNameFor
		
		fsa.generateFile(className + '.sql', model.doGenerateCode)
	}
	
	def deriveClassNameFor(Resource resource) {
		val origName = resource.URI.lastSegment

		origName.substring(0, origName.indexOf('.'))
	}
	
	def String doGenerateCode(FSQL program) '''
		«program.dbStatements.map[generateSQLDBCommand].join('\n')»
		«program.tableStatements.map[generateSQLTableCommand].join('\n')»
		
	'''
	
	dispatch def String generateSQLDBCommand(DatabaseStatements dbStmt) '''
	'''
	
	dispatch def String generateSQLDBCommand(CreateDB createDB) '''
		CREATE DATABASE «createDB.getName»;
	'''
	
	dispatch def String generateSQLDBCommand(UseDB useDB) '''
		USE «useDB.getDatabase().^var.name»;
	'''
	
	dispatch def String generateSQLTableCommand(TableStatements tableStmt)'''
	'''
	
	dispatch def String generateSQLTableCommand(CreateTable createTable)'''
	'''
	
	dispatch def String generateSQLTableCommand(InitTable initTable)'''
	'''
	
	dispatch def String generateSQLTableCommand(SchemaDeclaration schema)'''
		CREATE TABLE «schema.table.get(0).^var.name»(
			«schema.column.map[generateSQLColumns].join('\n')»
			«schema.columns.map[generateSQLColumns].join('')»
		)
	'''
	
	// this will generate SQL code for each column declaration
	dispatch def String generateSQLColumns(ColumnDeclaration column)''''''
	
	dispatch def String generateSQLColumns(SimpleDeclaration column)'''
		«column.getName»  «if (column.type === ColumnType.BOOL) {'''NUMBER(1)'''} else if (column.type === ColumnType.STRING) {'''VARCHAR(255)'''} else {column.type}»
	'''
	
	dispatch def String generateSQLColumns(PrimaryKey column)'''
		«column.column.generateSQLColumns» PRIMARY KEY
	'''
	
	dispatch def String generateSQLColumns(ForeignKey column)'''
		FOREIGN KEY «column.getColumn().^var.generateSQLColumns.split(' ').get(0)» REFERENCES «column.table.get(0).^var.name»(«column.getColumn().^var.generateSQLColumns.split(' ').get(0)»)
	'''
}