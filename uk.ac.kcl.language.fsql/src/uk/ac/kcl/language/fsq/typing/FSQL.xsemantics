import uk.ac.kcl.language.fsql.validation.AbstractFSQLValidator
import uk.ac.kcl.language.fsql.fSQL.ColumnValueType
import uk.ac.kcl.language.fsql.fSQL.IntType
import uk.ac.kcl.language.fsql.fSQL.RealType
import uk.ac.kcl.language.fsq.typing.FSQLType
import uk.ac.kcl.language.fsql.fSQL.AssignColumnValue
import uk.ac.kcl.language.fsql.fSQL.StringType
import uk.ac.kcl.language.fsql.fSQL.BoolType

system uk.ac.kcl.language.fsql.typing.FSQLTypeSystem

validatorExtends AbstractFSQLValidator

auxiliary {
	typeExpressions(Iterable<ColumnValueType> exps) : FSQLType cached
}

judgments {
	type |- ColumnValueType exp : output FSQLType
		cached
		error "cannot type " + stringRep(exp)
	subType |- FSQLType left <: FSQLType right
		error stringRep(left) + " is not a subtype of " + stringRep(right)
}

auxiliary typeExpressions(Iterable<ColumnValueType> exps) {
	if (exps.forall[exp | 
			empty |- exp : var FSQLType exp2Type 
			exp2Type === FSQLType.INT]) {
		return FSQLType.INT			
	} else if (exps.forall[exp | 
			empty |- exp : var FSQLType exp2Type 
			exp2Type === FSQLType.FLOAT]){
		return FSQLType.INT
	} else if (exps.forall[exp | 
			empty |- exp : var FSQLType exp2Type 
			exp2Type === FSQLType.STRING]){
		return FSQLType.INT
	} else {
		return FSQLType.INT
	}
}


rule SubTyping
	G |- FSQLType left <: FSQLType right
from {
	right === FSQLType.FLOAT or left === right
}

//rule StringTyping
//	G |- ColumnValueType decl : FSQLType t
//from {
//	t  = (decl).typeExpressions
//}

axiom IntLiteral 
	G |- IntType decl : FSQLType.INT
	
axiom RealLiteral 
	G |- RealType decl : FSQLType.FLOAT
	
axiom StringLiteral 
	G |- StringType decl : FSQLType.INT
	
axiom BoolLiteral 
	G |- BoolType decl : FSQLType.INT
	
checkrule checkAssignColumnValue for
	AssignColumnValue stmt
from {
	empty |- stmt.value : var FSQLType colType
	empty |- colType <: FSQLType.INT
}
